module Library where

-- The standalone version of the Gradualizer uses Library only for retrieving the names of the languages. 
-- The website version of the Gradualizer retrieves the language definitions from Library, also. 
-- This is because the website version does not read from files.

import TypeSystem
import ToLambdaProlog

librarySig :: [(String, String)]
librarySig = [
  ("none", ""),
  ("stlc", "sig stlc.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_integers", "sig stlc_integers.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\ntype \tsucc \t\tterm -> term.\ntype \tzero \t\tterm.\ntype \tpred \t\tterm -> term.\ntype \terror \t\tterm.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_exc", "sig stlc_exc.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\ntype\terror\t\t\tterm -> o.\n\ntype\t\texcType\t\t\ttyp.\ntype\t\traise\t\t\ttyp -> term -> term.\ntype\t\ttry\t\t\t\tterm -> term -> term.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_fix", "sig stlc_fix.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tfix\t\tterm -> term.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_if", "sig stlc_if.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tbool\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tif\t\tterm -> term -> term -> term.\ntype\t\ttt\tterm.\ntype\t\tff\tterm.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_inference", "sig stlc_inference.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tabsInf\t\t(term -> term) -> term.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_let", "sig stlc_let.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tlet\t\tterm -> (term -> term) -> term.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_letrec", "sig stlc_letrec.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tfix\t\tterm -> term.\ntype\t\tlet\t\tterm -> (term -> term) -> term.\ntype\t\tletrec\t\ttyp -> (term -> term) -> (term -> term) -> term.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_lists", "sig stlc_lists.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\n\n\n%type map typ -> term -> term -> term.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\ntype\terror\t\t\tterm -> o.\n\ntype\tbool\t\t\ttyp.\ntype\tlist\t\t\ttyp -> typ.\n\ntype\ttt\t\tterm.\ntype\tff\t\tterm.\ntype\temptyList\ttyp -> term.\ntype\tisnil\t\ttyp -> term -> term. \ntype\tcons\t\ttyp -> term -> term -> term. \ntype\thead \t\ttyp -> term -> term. \ntype\ttail \t\ttyp -> term -> term.\ntype myError term. \n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_pairs", "sig stlc_pairs.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\ttimes\t\ttyp -> typ -> typ.\ntype\tpair\t\t\tterm -> term -> term.\ntype\tfst\t\t\t\tterm -> term.\ntype\tsnd\t\t\t\tterm -> term.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_ref", "sig stlc_ref.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\ntype\tzero\t\tterm.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \ntype\tstep\t\t\tterm -> term -> o.\ntype\tstepRef\t\t\tterm -> heap -> term -> heap -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\trefType\t\ttyp -> typ.\ntype\tunitType\ttyp.\n\ntype\tunit\t\tterm.\ntype\tref\t\t\tterm -> term.\ntype\tderef\t\tterm -> term.\ntype\tassign\t\tterm -> term -> term.\n\n% addresses and environment\nkind \taddress\t\t\ttype.\ntype\tloc\t\t\t\taddress -> term. \n\n% heaps\nkind \theap\t\t\t\ttype.\n\ntype \t\temptyHeap\theap.\ntype \t\theapCons\taddress -> term -> heap -> heap.\ntype\t\theapLookup\theap -> address -> term -> o.\n\ntype\t\tfresh\t\taddress -> heap -> o.\n\ntype\tmultistepRef\tterm -> heap -> term -> heap -> o.\n"),
--  ("stlc_subtype", "sig stlc_subtype.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\ntype\tsubtype\t\t\ttyp -> typ -> o.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% context app 1[], 2[1].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n% mode subtype inp -> inp.\n"),
  ("stlc_sum", "sig stlc_sum.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype sum typ -> typ -> typ.\n\ntype\t\tcase \t\tterm -> (term -> term) -> (term -> term) -> term.\ntype\t\tinl\t\t\ttyp -> term -> term.\ntype\t\tinr\t\t\ttyp -> term -> term.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_tuples", "sig stlc_tuples.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\ttupleType\t\ttyp -> typ -> typ -> typ -> typ.\ntype\ttuple\t\t\tterm -> term -> term -> term -> term.\ntype\tselect1\t\t\t\tterm -> term.\ntype\tselect2\t\t\t\tterm -> term.\ntype\tselect3\t\t\t\tterm -> term.\ntype\tselect4\t\t\t\tterm -> term.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlc_unit", "sig stlc_unit.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype \tunitType \ttyp.\ntype\tunit\t\tterm.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("systemF", "sig systemF.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype \tall \t\t\t(typ -> typ) -> typ.\ntype    appT\t\t\tterm -> typ -> term.\ntype    absT\t\t\t(typ -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("recursive", "sig recursive.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype \tmu \t\t\t(typ -> typ) -> typ.\ntype \tfold \t\tterm -> (typ -> typ) -> term.\ntype    unfold\t\tterm -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("stlcCBN", "sig stlc.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\tint\t\t\ttyp.\ntype\tzero\t\tterm.\ntype\tmultistep\t\t\tterm -> term -> o.\n"),
  ("fpl", "sig fpl.\n\nkind term type.\nkind typ type.\n\n%type map typ -> term -> term -> term.\ntype int typ.\ntype bool typ.\ntype arrow typ -> typ -> typ.\ntype list typ -> typ.\ntype sum typ -> typ -> typ.\ntype times typ -> typ -> typ.\ntype all (typ -> typ) -> typ.\ntype mu (typ -> typ) -> typ.\ntype succ term -> term.\ntype zero term.\ntype isZero term -> term.\ntype pred term -> term.\ntype ff term.\ntype tt term.\ntype if term -> term -> term -> term.\ntype abs typ -> (term -> term) -> term.\ntype app term -> term -> term.\ntype emptyList typ -> term.\ntype cons typ -> term -> term -> term.\ntype isnil typ -> term -> term.\ntype tail typ -> term -> term.\ntype head typ -> term -> term.\ntype inl typ -> term -> term.\ntype inr typ -> term -> term.\ntype case term -> (term -> term) -> (term -> term) -> term.\ntype pair term -> term -> term.\ntype fst term -> term.\ntype snd term -> term.\ntype absT (typ -> term) -> term.\ntype appT term -> typ -> term.\ntype fold term -> (typ -> typ) -> term.\ntype unfold term -> term.\ntype fix term -> term.\ntype let term -> (term -> term) -> term.\ntype letrec typ -> (term -> term) -> (term -> term) -> term.\ntype try term -> term -> term.\ntype raise typ -> term -> term.\n\ntype value term -> o.\n\ntype error term -> o.\n\n\ntype typeOf term -> typ -> o.\n\ntype step term -> term -> o.\n\ntype multistep term -> term -> o.\n")
           ]

libraryRules :: [(String, String)]
libraryRules = [
  ("none", ""),
  ("stlc", "module stlc.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\n\nvalue (abs T E).\nvalue (zero).\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% eliminator app 1.\n"),
  ("stlc_integers", "module stlc_integers.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (succ E) (int ) :- typeOf E (int ).\ntypeOf (pred E) (int ) :- typeOf E (int ).\n\nvalue (abs T E).\nvalue (zero).\nvalue (succ V) :- value V.\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (pred (zero )) (error).\nstep (pred (succ V)) V :- value V.\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context succ 1[].\n% context pred 1[].\n% eliminator app 1.\n% eliminator pred 1.\n"),
  ("stlc_exc", "module stlc_exc.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (raise T E) T :- typeOf E (excType).\ntypeOf (try E1 E2) T :- typeOf E1 T, typeOf E2 (arrow (excType) T).\n\nvalue (abs T E).\nvalue (zero).\nerror (raise T V) :- value V.\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (try V E)  V :- value V.\nstep (try (raise T V) E)  (app E V) :- value V.\n\nstep E (raise T1 V) :- typeOfCC V T1, containsError E (raise T2 V), value V.\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context try 1[].\n% context raise 2[].\n% eliminator app 1.\n% errorHandler try.\n"),
   ("stlc_fix", "module stlc_fix.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (fix E) T :- typeOf E (arrow T T).\n\nvalue (abs T E).\nvalue (zero).\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (fix V) (app V (fix V)) :- value V.\n\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context fix 1[].\n% eliminator app 1.\n"),
  ("stlc_if", "module stlc_if.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (if E1 E2 E3) T :- typeOf E1 (bool), typeOf E2 T, typeOf E3 T.\ntypeOf (tt) (bool).\ntypeOf (ff) (bool).\n\nvalue (abs T E).\nvalue (tt).\nvalue (ff).\nvalue (zero).\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (if (tt) E1 E2) E1. \nstep (if (ff) E1 E2) E2. \n\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context if 1[].\n% eliminator app 1.\n% eliminator if 1.\n"),
  ("stlc_inference", "module stlc_inference.\n\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (absInf E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (zero) (int).\n\nvalue (absInf E).\nvalue (zero).\n\nstep (app (absInf E1) E2) (E1 E2) :- value E2.\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% eliminator app 1.\n"),
  ("stlc_let", "module stlc_let.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (let E1 E2) T2 :- typeOf E1 T1, (pi x\\ typeOf x T1 => typeOf (E2 x) T2).\n\nvalue (abs T E).\nvalue (zero).\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (let V E) (E V) :- value V.\n\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context let 1[].\n% eliminator app 1.\n"),
  ("stlc_letrec", "module stlc_letrec.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (fix E) T :- typeOf E (arrow T T).\ntypeOf (let E1 E2) T2 :- typeOf E1 T1, (pi x\\ typeOf x T1 => typeOf (E2 x) T2).\ntypeOf (letrec T1 E1 E2) T2 :- (pi x\\ typeOf x T1 => typeOf (E1 x) T1), (pi x\\ typeOf x T1 => typeOf (E2 x) T2).\n\nvalue (abs T E).\nvalue (zero).\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (fix V) (app V (fix V)) :- value V.\nstep (let V E) (E V) :- value V.\nstep (letrec T E1 E2) (let (fix (abs T E1)) E2).\n\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context fix 1[].\n% context let 1[].\n% eliminator app 1.\n"),
  ("stlc_lists", "module stlc_lists.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (tt) (bool).\ntypeOf (ff) (bool).\ntypeOf (emptyList T) (list T).\ntypeOf (isnil T E) (bool) :- typeOf E (list T).\ntypeOf (cons T E1 E2) (list T) :- typeOf E1 T, typeOf E2 (list T).\ntypeOf (head T E) T :- typeOf E (list T).\ntypeOf (tail T E) (list T) :- typeOf E (list T).\n\nvalue (abs T E).\nvalue (zero).\nvalue (tt).\nvalue (ff).\nvalue (emptyList T).\nvalue (cons T V1 V2) :- value V1, value V2.\nerror (myError).\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (isnil T (emptyList T)) (tt).\nstep (isnil T (cons T V1 V2)) (ff) :- value V1, value V2.\nstep (head T (emptyList T)) (myError).\nstep (head T (cons T V1 V2)) V1 :- value V1, value V2.\nstep (tail T (emptyList T)) (myError).\nstep (tail T (cons T V1 V2)) V2 :- value V1, value V2.\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context cons 2[], 3[2].\n% context head 2[].\n% context tail 2[].\n% context isnil 2[].\n% eliminator app 1.\n% eliminator head 2.\n% eliminator tail 2.\n% eliminator isnil 2.\n%typeOf (map T2 E1 E2) (list T2) :- typeOf E1 (arrow T1 T2), typeOf E2 (list T1).\n%step (map T2 V1 (emptyList T1)) (emptyList T2).\n%step (map T V1 (cons T1 V2 V3)) (cons T1 (app V1 V2) (map T V1 V3)) :- value V1, value V2, value V3.\n%% eliminator map 3.\n"),
  ("stlc_pairs", "module stlc_pairs.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (pair E1 E2) (times T1 T2) :- typeOf E1 T1, typeOf E2 T2.\ntypeOf (fst E) T1 :- typeOf E (times T1 T2).\ntypeOf (snd E) T2 :- typeOf E (times T1 T2).\n\nvalue (abs T E).\nvalue (zero).\nvalue (pair V1 V2) :- value V1, value V2.\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (fst (pair V1 V2)) V1 :- value V1, value V2.\nstep (snd (pair V1 V2)) V2 :- value V1, value V2.\n\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context pair 1[],2[1].\n% context fst 1[].\n% context snd 1[].\n% eliminator app 1.\n% eliminator fst 1.\n% eliminator snd 1.\n"),
  ("stlc_ref", "module stlc_ref.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (unit) (unitType).\ntypeOf (ref E) (refType T) :- typeOf E T.\ntypeOf (deref E) T :- typeOf E (refType T).\ntypeOf (assign E1 E2) (unitType) :- typeOf E1 (refType T), typeOf E2 T.\n\n\nvalue (abs T E).\nvalue (zero).\nvalue (unit).\nvalue (loc Addr).\n\nstepRef (app (abs T E1) E2) Mu (E1 E2) Mu :- value E2.\nstepRef (ref V) Mu (Loc Addr) (heapCons Addr V Mu) :- fresh Addr Mu, value V.\nstepRef (assign (loc Addr) V) Mu (unit) (heapCons Addr V Mu) :- value V.\nstepRef (deref (loc Addr)) Mu V Mu :- heapLookup Mu Addr V.\n\nstepRef E Mu E' Mu :- step E E'.\n\nheapLookup (heapCons Addr E Mu) Addr E.\nheapLookup (heapCons Addr1 E1 Mu) Addr2 E2 :- heapLookup Mu Addr2 E2.\n\n% The predicate fresh generates a new address not in the heap Mu. \n% This predicate is left unspecified. Lambda-prolog, just like functional programs, is pure.\n% stlc_ref simply demonstrates that the Gradualizer can generate the correct rules for assign and deref in gradual_stlc_ref.\n\nmultistepRef E Mu E Mu.\nmultistepRef E1 Mu1 E3 Mu3 :- stepRef E1 Mu1 E2 Mu2, multistepRef E2 Mu2 E3 Mu3. \n\n% context app 1[], 2[1].\n% context ref 1[].\n% context deref 1[].\n% context assign 1[],2[1].\n% eliminator app 1.\n% eliminator assign 1.\n% eliminator deref 1.\n"),
 -- ("stlc_subtype", "module stlc_subtype.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T3, subtype T1 T3.\nvalue (abs T E).\nstep (app (abs T E1) E2) (E1 E2).\n"),
  ("stlc_sum", "module stlc_sum.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (case E E1 E2) T :- typeOf E (sum T1 T2), (pi x\\ typeOf x T1 => typeOf (E1 x) T), (pi x\\ typeOf x T2 => typeOf (E2 x) T).\ntypeOf (inl T2 E) (sum T1 T2) :- typeOf E T1.\ntypeOf (inr T1 E) (sum T1 T2) :- typeOf E T2.\n\nvalue (abs T E).\nvalue (zero).\nvalue (inl T V) :- value V.\nvalue (inr T V) :- value V.\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (case (inl T V) E1 E2) (E1 V) :- value V.\nstep (case (inr T V) E1 E2) (E2 V) :- value V.\n\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context inr 2[].\n% context inl 2[].\n% context case 1[].\n% eliminator app 1.\n% eliminator case 1.\n"),
  ("stlc_tuples", "module stlc_tuples.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (tuple E1 E2 E3 E4) (tupleType T1 T2 T3 T4) :- typeOf E1 T1, typeOf E2 T2, typeOf E3 T3, typeOf E4 T4.\ntypeOf (select1 E) T1 :- typeOf E (tupleType T1 T2 T3 T4).\ntypeOf (select2 E) T2 :- typeOf E (tupleType T1 T2 T3 T4).\ntypeOf (select3 E) T3 :- typeOf E (tupleType T1 T2 T3 T4).\ntypeOf (select4 E) T4 :- typeOf E (tupleType T1 T2 T3 T4).\n\nvalue (abs T E).\nvalue (zero).\nvalue (tuple V1 V2 V3 V4) :- value V1, value V2, value V3, value V4. \n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (select1 (tuple V1 V2 V3 V4)) E1 :- value V1, value V2, value V3, value V4. \nstep (select2 (tuple V1 V2 V3 V4)) E2 :- value V1, value V2, value V3, value V4. \nstep (select3 (tuple V1 V2 V3 V4)) E3 :- value V1, value V2, value V3, value V4. \nstep (select4 (tuple V1 V2 V3 V4)) E4 :- value V1, value V2, value V3, value V4. \n\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context tuple 1[],2[1],3[1,2],4[1,2,3].\n% context select1 1[].\n% context select2 1[].\n% context select3 1[].\n% context select4 1[].\n% eliminator app 1.\n% eliminator select1 1.\n% eliminator select2 1.\n% eliminator select3 1.\n% eliminator select4 1.\n"),
  ("stlc_unit", "module stlc_unit.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (unit) (unitType).\n\nvalue (abs T E).\nvalue (zero).\nvalue (unit).\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% eliminator app 1.\n"),
  ("systemF", "module systemF.\n\ntypeOf (abs T1 R) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (R x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (absT R2) (all R) :- (pi x\\ typeOf (R2 x) (R x)).\ntypeOf (appT E T) (R T) :- typeOf E (all R).\n\nvalue (abs T E).\nvalue (zero).\nvalue (absT R).\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (appT (absT R) T) (R T).\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context appT 1[].\n% eliminator app 1.\n% eliminator appT 1.\n"),
  ("recursive", "module recursive.\n\ntypeOf (abs T1 R) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (R x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\ntypeOf (fold E R) (mu R) :- typeOf E (R (mu R)).\ntypeOf (unfold E) (R (mu R)) :- typeOf E (mu R).\n\nvalue (abs T E).\nvalue (zero).\nvalue (fold V R) :- value V.\n\nstep (app (abs T E1) E2) (E1 E2) :- value E2.\nstep (unfold (fold V R)) V :- value V.\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[], 2[1].\n% context fold 1[].\n% context unfold 1[].\n% eliminator app 1.\n% eliminator unfold 1.\n"),
  ("stlcCBN", "module stlc.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (E x) T2).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (zero) (int).\n\nvalue (abs T E).\nvalue (zero).\n\nstep (app (abs T E1) E2) (E1 E2).\n\nmultistep E E.\nmultistep E1 E3 :- step E1 E2, multistep E2 E3. \n\n% context app 1[].\n% eliminator app 1.\n"),
  ("fpl", "module fpl.\n\ntypeOf (zero ) (int ).\n\ntypeOf (succ E) (int ) :- typeOf E (int ).\n\ntypeOf (pred E) (int ) :- typeOf E (int ).\n\ntypeOf (isZero E) (bool ) :- typeOf E (int ).\n\ntypeOf (ff ) (bool ).\n\ntypeOf (tt ) (bool ).\n\ntypeOf (if E1 E2 E3) T :- typeOf E1 (bool ), typeOf E2 T, typeOf E3 T.\n\ntypeOf (abs T1 R) (arrow T1 T2) :- (pi x\\ typeOf x T1 => typeOf (R x) T2).\n\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\n\ntypeOf (emptyList T) (list T).\n\ntypeOf (cons T E1 E2) (list T) :- typeOf E1 T, typeOf E2 (list T).\n\ntypeOf (isnil T E) (bool ) :- typeOf E (list T).\n\ntypeOf (tail T E) (list T) :- typeOf E (list T).\n\ntypeOf (head T E) T :- typeOf E (list T).\n\ntypeOf (inr T1 E) (sum T1 T2) :- typeOf E T2.\n\ntypeOf (inl T2 E) (sum T1 T2) :- typeOf E T1.\n\ntypeOf (case E R1 R2) T :- typeOf E (sum T1 T2), (pi x\\ typeOf x T1 => typeOf (R1 x) T), (pi x\\ typeOf x T2 => typeOf (R2 x) T).\n\ntypeOf (pair E1 E2) (times T1 T2) :- typeOf E1 T1, typeOf E2 T2.\n\ntypeOf (fst E) T1 :- typeOf E (times T1 T2).\n\ntypeOf (snd E) T2 :- typeOf E (times T1 T2).\n\ntypeOf (absT R2) (all R) :- (pi x\\ typeOf (R2 x) (R x)).\n\ntypeOf (appT E T) (R T) :- typeOf E (all R).\n\ntypeOf (unfold E) (R (mu R)) :- typeOf E (mu R).\n\ntypeOf (fold E R) (mu R) :- typeOf E (R (mu R)).\n\ntypeOf (fix E) T :- typeOf E (arrow T T).\n\ntypeOf (let E R) T2 :- typeOf E T1, (pi x\\ typeOf x T1 => typeOf (R x) T2).\n\ntypeOf (letrec T1 R1 R2) T2 :- (pi x\\ typeOf x T1 => typeOf (R1 x) T1), (pi x\\ typeOf x T1 => typeOf (R2 x) T2).\n\ntypeOf (try E1 E2) T :- typeOf E1 T, typeOf E2 (arrow (int ) T).\n\ntypeOf (raise T E) T :- typeOf E (int ).\n\nstep (app (abs T R) V) (R V) :- value V.\n\nstep (pred (zero )) (raise (int) (zero )).\n\nstep (pred (succ V)) V :- value V.\n\nstep (isZero (zero )) (tt ).\n\nstep (isZero (succ V)) (ff ) :- value V.\n\nstep (if (tt ) E1 E2) E1.\n\nstep (if (ff ) E1 E2) E2.\n\nstep (case (inl T V) E1 E2) (E1 V) :- value V.\n\nstep (case (inr T V) E1 E2) (E2 V) :- value V.\n\nstep (snd (pair V1 V2)) V2 :- value V1, value V2.\n\nstep (fst (pair V1 V2)) V1 :- value V1, value V2.\n\nstep (isnil T (emptyList T')) (tt ).\n\nstep (isnil T (cons T V1 V2)) (ff) :- value V1, value V2.\n\nstep (tail T (emptyList T')) (raise (list T) (succ (zero ))).\n\nstep (tail T (cons T V1 V2)) V2 :- value V1, value V2.\n\nstep (head T (emptyList T')) (raise T (zero )).\n\nstep (head T (cons T V1 V2)) V1 :- value V1, value V2.\n\nstep (appT (absT R2) T) (R2 T).\n\nstep (unfold (fold V R)) V :- value V.\n\nstep (let V R) (R V) :- value V.\n\nstep (letrec T1 R1 R2) (R2 (fix (abs T1 R1))).\n\nstep (fix V) (app V (fix V)) :- value V.\n\nstep (try E1 E2) E1 :- value E1.\nstep (try (raise T V1) V2)  (app V2 V1) :- value V1, value V2.\n\nvalue (zero ).\n\nvalue (succ E1) :- value E1.\n\nvalue (tt ).\n\nvalue (ff ).\n\nvalue (abs T1 R2).\n\nvalue (inr T V) :- value V.\n\nvalue (inl T E1) :- value E1.\n\nvalue (emptyList T1).\n\nvalue (cons T1 E2 E3) :- value E2, value E3.\n\nvalue (pair E1 E2) :- value E1, value E2.\n\nvalue (absT R1).\n\nvalue (fold E1 U2) :- value E1.\n\nerror (raise T V) :- value V. \n\nstep E (raise T1 V) :- typeOf E T1, containsError E (raise T2 V), value V. \n\nmultistep E E.\n\nmultistep E1 E3 :- step E1 E2, multistep E2 E3.\n\n% context succ 1[].\n% context pred 1[].\n% context isZero 1[].\n% context app 1[], 2[1].\n% context if 1[].\n% context pair 1[], 2[1].\n% context fst 1[].\n% context snd 1[].\n% context inr 2[].\n% context inl 2[].\n% context case 1[].\n% context cons 2[], 3[2].\n% context head 2[].\n% context tail 2[].\n% context isnil 2[].\n% context appT 1[].\n% context fold 1[].\n% context unfold 1[].\n% context let 1[].\n% context fix 1[].\n% context try 1[].\n% context raise 2[].\n% eliminator app 1.\n% eliminator if 1.\n% eliminator pred 1.\n% eliminator isZero 1.\n% eliminator fst 1.\n% eliminator snd 1.\n% eliminator case 1.\n% eliminator head 2.\n% eliminator tail 2.\n% eliminator isnil 2.\n% eliminator appT 1.\n% eliminator unfold 1.\n% errorHandler try.\n\n%typeOf (map T2 E1 E2) (list T2) :- typeOf E1 (arrow T1 T2), typeOf E2 (list T1).\n%step (map T2 V1 (emptyList T1)) (emptyList T2).\n%step (map T V1 (cons T1 V2 V3)) (cons T1 (app V1 V2) (map T V1 V3)) :- value V1, value V2, value V3.\n%% eliminator map 3.\n")
           ]

		   

preLibrary :: [String]
preLibrary =
           [
           "none",
           "stlc",
           "stlc_integers",
           "stlc_exc",
           "stlc_fix",
           "stlc_if",
           "stlc_inference",
           "stlc_let",
           "stlc_letrec",
           "stlc_lists",
           "stlc_pairs",
           "stlc_ref",
         --  "stlc_subtype",
           "stlc_sum",
           "stlc_tuples",
           "stlc_unit",
           "systemF",
           "recursive",
           "stlcCBN",
           "fpl"
           ]

getSelectionSig :: Int -> Maybe String
getSelectionSig n = lookup (preLibrary !! n) librarySig

getSelectionRules :: Int -> Maybe String
getSelectionRules n = lookup (preLibrary !! n) libraryRules

preLibraryWithTitles  :: [(String, String)]
preLibraryWithTitles =
           [
           ("none", ""),
           ("stlc", "Simply Typed Lambda Calculus (STLC)"),
           ("stlc_integers", "STLC with Integers"),
           ("stlc_exc", "STLC with Exceptions"),
           ("stlc_fix", "STLC with Recursion (Fix operator)"), 
           ("stlc_if", "STLC with Booleans and If-statement"),
           ("stlc_inference", "STLC in Type Inference style"), 
           ("stlc_let", "STLC with Let bindings"),
           ("stlc_letrec", "STLC with Letrec bindings"), 
           ("stlc_lists", "STLC with Lists"), 
           ("stlc_pairs", "STLC with Pairs"), 
           ("stlc_ref", "STLC with References"), 
           ("stlc_subtype", "STLC with Subtyping"),
           ("stlc_sum", "STLC with Sum Types"), 
           ("stlc_tuples", "STLC with the Tuples"), 
           ("stlc_unit", "STLC with the Unit type"),
           ("fpl", "FPL")
           ]

